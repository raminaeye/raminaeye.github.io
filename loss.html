<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Deep Learning Loss Functions: BCE, CE, and CTC</title>
  <style>
    body {
      font-family: sans-serif;
      max-width: 900px;
      margin: 0 auto;
      padding: 2rem;
      line-height: 1.6;
      color: #333;
    }
    h1, h2, h3, h4 {
      color: #2c3e50; /* Darker shade for better contrast */
      margin-top: 1.5em;
      margin-bottom: 0.5em;
    }
    h1 { font-size: 2.5em; border-bottom: 2px solid #3498db; padding-bottom: 0.3em;}
    h2 { font-size: 2em; border-bottom: 1px solid #bdc3c7; padding-bottom: 0.2em;}
    h3 { font-size: 1.5em; }
    h4 { font-size: 1.2em; color: #555;}

    nav { margin-bottom: 30px; padding: 10px; background: #ecf0f1; border: 1px solid #bdc3c7; border-radius: 4px;}
    nav ul { list-style: none; padding: 0; }
    nav li { display: inline-block; margin-right: 15px; }
    nav a { text-decoration: none; color: #3498db; font-weight: bold;}
    nav a:hover { text-decoration: underline; color: #2980b9;}

    pre {
      background: #f8f9f9; /* Lighter background for code blocks */
      padding: 1rem;
      overflow-x: auto;
      border: 1px solid #e1e4e8; /* Softer border */
      border-left: 4px solid #3498db; /* Accent border */
      border-radius: 4px;
      font-size: 0.9em;
    }
    code {
      font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
    }
    /* For inline code */
    p > code, li > code, table td > code {
      background: #e8eaed;
      padding: 0.2em 0.4em;
      border-radius: 3px;
      font-size: 0.85em;
    }
    pre code { /* Reset for code inside pre, already handled by pre styling */
        background: none;
        padding: 0;
        font-size: 1em; /* Ensure pre's font size is inherited */
    }
    ul, ol {
        padding-left: 20px;
    }
    li {
        margin-bottom: 0.5em;
    }
    strong {
        color: #2980b9;
    }
    /* Math block centering */
    .math-display {
        text-align: center;
        margin: 1rem 0;
    }
  </style>
  
  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
        processEscapes: true
      }
    });
  </script>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/monokai.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
</head>
<body>
   <nav>
     <ul>
       <li><a href="#">Home</a></li> 
       <li><a href="#">Loss Functions Notebook</a></li>
     </ul>
   </nav>

   <h1>Deep Learning Loss Functions</h1>
   
   <p>You know me, I’m gonna talk about loss functions now! Let’s start with binary cross entropy.</p>

   <h2>1. Binary Cross Entropy (BCE)</h2>
   
   <p>The formula for BCE is defined as:</p>
   
   <div class="math-display">
   $$ L = -\sum_i (y_i \log(p'_i) + (1-y_i)\log(1-p'_i)) $$
   </div>

   <p>Where $p'_i$ is the $\text{sigmoid}(\text{logit}_i)$ and $y_i$ is whether a class was present (ground truth).</p>

   <p>First, you squash logits into probabilities using sigmoid. Then, you compare that prediction with ground truth using BCE loss. With BCE, each class is an independent binary prediction. You can even extend this to multiple labels. You can pass each logit through a sigmoid, compute binary cross entropy per class, and average over classes. This lets you model <strong>multiple classes co-occurring</strong>.</p>
   
   <p>With BCE you can’t compress the label into one integer anymore, so you need to have a multi-hot vector. You must determine the cross-entropy for each class and then sum over them.</p>

   <div class="math-display">
   $$ BCE(y,p) = -\sum_{i=1}^C(y_i \log(p_i) + (1-y_i) \log(1-p_i)) $$
   </div>

   <p>This checks every class independently. BCE needs a multi-hot vector because each class is treated as an independent yes/no problem.</p>

<pre><code class="language-python">def bce_with_logits_loss(logits, targets):
    """
    logits: (N, C) raw outputs
    targets: (N, C) multi-hot labels {0,1}
    """
    # sigmoid
    probs = 1 / (1 + torch.exp(-logits))

    # binary cross entropy per class
    bce = -(targets * torch.log(probs) + (1 - targets) * torch.log(1 - probs))

    # average over classes and batch
    loss = bce.mean()
    return loss
</code></pre>

   <h2>2. Categorical Cross Entropy</h2>

   <p>Categorical cross entropy is a special case of BCE with a one-hot target. For classes with logits, and probabilities $p_i = \text{sigmoid}(z_i)$ and target in 0 and 1. Only one class is true at a time.</p>

   <p>With categorical cross entropy you apply a <strong>softmax</strong> over logits and get a probability over $C$ classes.</p>

   <div class="math-display">
   $$ P_i = \frac{\exp(z_j)}{\sum_j(\exp(z_j))} $$
   </div>

   <p>Then you apply categorical cross-entropy against a one-hot target. If the predicted probability for the correct class $k$ is $p$, then CE is:</p>

   <div class="math-display">
   $$ CE = -\log P(\text{true\_class}) $$
   </div>

   <p>It only looks at the correct class’s probability. CE assumes <strong>mutual exclusivity</strong>—that exactly one class is correct. So, that’s why you get categorical cross entropy, you can show it as a single index. Internally, PyTorch converts that into a one-hot vector. The loss just turns into taking the probability of the correct class.</p>

   <p>Remember negative log means lower loss is higher probability; it’s just like the negative log likelihood of the true class under the predicted distribution. If the model was super sure, like 0.9, then the negative loss of that would be 0.1 and if it wasn’t sure like 0.1 it would be around 2.3. CE punishes the model when it assigns low probability to the true class.</p>

<pre><code class="language-python">def cross_entropy_loss(logits, target_index):
    """
    logits: (N, C) raw outputs
    target_index: (N,) integer labels (0 <= y < C)
    """
    # softmax
    exp_logits = torch.exp(logits)
    probs = exp_logits / exp_logits.sum(dim=1, keepdim=True)

    # pick probability of the correct class
    correct_class_probs = probs[torch.arange(len(target_index)), target_index]

    # negative log likelihood
    loss = -torch.log(correct_class_probs).mean()
    return loss
</code></pre>

   <h2>3. The Alignment Problem</h2>

   <p>If we had a sequence of input frames, and we knew the label for each frame (we don’t here) then we could just apply CE at each frame and average.</p>

   <div class="math-display">
   $$ \text{Loss} = -\frac{1}{T} \sum_{t=1}^T(\log(p_{(t,y_t)})) $$
   </div>

   <p>Where $y_t$ is the ground truth label for frame $t$. But this assumes a frame-to-label alignment. We don’t have labels for every frame and the target tokens are much shorter than input. The speech sequence length typically 1000 frames for 10 sec is much longer than the text token, maybe 20 words and we don’t know frame to token alignment.</p>

   <p>We need a loss that doesn’t require explicit alignment and can collapse variable length frame prediction into a shorter token length. This is where <strong>“Connectionist Temporal Classification” (CTC)</strong> loss comes to play.</p>

   <h2>4. Connectionist Temporal Classification (CTC)</h2>

   <p>CTC augments the vocabulary with a <strong>black token</strong>, no label. This allows the frames to correspond to no output symbols. So, now you have $T$ frames and each frame gets a probability distribution over $V+1$ (tokens + label).</p>

   <p>To get final transcriptions from a frame sequence you have to merge their predictions. You merge repeated tokens and remove blanks. CTC loss uses dynamic programming to sum the probabilities of all possible alignments between frames and target tokens and does this efficiently.</p>

   <h3>Merging Predictions</h3>
   
   <p>Each frame has a probability mass over many tokens and thus can create multiple alignments. We sum over all valid alignments that lead to ground truth. But, this is a lot of alignments. Over $T$ frames with $|V| + 1$ possible paths, you get $(|V| + 1)^T$ paths. Even with a small vocabulary of 50 you could get $50^{100}$ paths.</p>

   <p>With CTC model doesn’t output one label, it outputs a probability distribution over all possible labels at each frame. Alignments are not generated arbitrarily from predictions, they are constrained by the ground truth. Alignment is one possible frame level sequence that when collapsed equal to the ground truth.</p>

   <p>The predictions supply the probability at each frame and the ground truth constrain which sequence of choices we care about. We compute the total probability of the ground truth string by summing over all valid alignment paths.</p>

   <div class="math-display">
   $$ P(y | x )  = \sum_{\pi \in B^{-1}(y)} \prod_{t=1}^T (p(\pi_t|x_t)) $$
   </div>

   <ul>
       <li>$Y$: ground truth sequence</li>
       <li>$X$: input sequence</li>
       <li>$p(\pi_t | x_t )$: model’s softmax probability of symbol $\pi_t$ at frame $t$</li>
       <li>$\pi = (\pi_1,..\pi_T)$: one alignment path</li>
       <li>$B(\pi)$: collapse function removes banks and merge repeats</li>
       <li>$B^{-1}(y)$: set of all alignments that collapse to the same ground truth</li>
   </ul>

   <p>Since multiple alignments can collapse to the same label sequence $y$, the total probability of $y$ is the sum of all alignment probabilities.</p>

   <p>The CTC loss is then just negative loss likelihood:</p>
   
   <div class="math-display">
   $$ L_{ctc} = -\log P(y|x) $$
   </div>

   <p>Well that’s a lot of math that you probably don’t need, but the big idea here is that we need to find the alignments that collapse to the target word and use our model’s probability predictions to score each valid alignment. CTC doesn’t enumerate every single alignment though. It uses <strong>forward-backward dynamic programming algorithm</strong> to efficiently sum their probabilities.</p>

   <h3>Dynamic Programming for CTC</h3>

   <p>At each input you can output either a symbol or a blank token. A valid alignment is any sequence of that collapse to the ground truth after removing blanks and merging consecutive duplicates. You can think of this as a leetcode hard problem, counting paths. We need to count how many paths collapse to the target sequence and once we have that we can replace those counts with probabilities.</p>

   <p>A naive CTC would be a softmax with repeat collapse. You consider the single argmax alignment and collapse repeats accordingly. It’s simple and fast and it <strong>doesn’t work</strong>! It assumes each character or phoneme is well aligned in time or clearly segmented. Misalignment and variable timing will cause errors.</p>

   <h4>Example</h4>
   <p>Let’s say we have 10 frames and take a small example like <strong>CAT</strong> and say our vocabulary is $\{C, A, T, blank\}$. Valid alignments are:</p>
   <ul>
       <li><code>{C, A, T, -}</code></li>
       <li><code>{C, A, -, T}</code></li>
       <li><code>{C, -, A, T}</code></li>
       <li><code>{-, C, A, T}</code></li>
   </ul>

   <p>We’re basically trying to insert our letters into 4 frames in order. If we had 10 frames and 4 letters that would be $4^{10}$ sequences, although most would not collapse to CAT.</p>

   <p>CTC builds an extended target sequence with blanks inserted: <strong>$Y’ = \_C\_A\_T\_$</strong>.</p>
   
   <p>Where length is $2U + 1$. Now let’s define a DP table. Our original target of length 3 has been extended to 7. Blanks are guard rails, they allow for variable timing and disambiguating repeats. Now think of aligning the 10 frames to the 7 positions in the extended sequence. At each frame you stay on the same symbol or move to the next symbol. Each step you can:</p>
   <ol>
       <li>Stay at the same position</li>
       <li>Move forward by 1 (always)</li>
       <li>Move forward by 2 (only if skipping a blank between different symbols)</li>
   </ol>

   <p>This is like a lattice, each node is $(t,s)$ at time $t$ and target position $s$. So, now our table looks like 10 frames/rows by 7 alignments/columns, ($T \times 2U+1$). Number of rows are your input length and columns are the extended target length. Time axis is how far we have processed the input and the extended target axis is how far we’ve matched in to the target string. A path through this grid is one alignment.</p>

   <p>From $(t,s)$ the dp says what is the probability (or count) of being aligned to this position $s$ in the extended target.</p>

   <h3>Forward Implementation</h3>
   
   <p>The transition rule: To compute $dp[t][s]$ you could get contribution from the same symbol $(t-1,s)$ or advance by 1 $(t-1,s-1)$ or skipped over the blank token if valid $(t-1, s-2)$. This is the forward algorithm. After filling the whole table the number of valid alignment is: $dp[T][s-2] + dp[T][s-1]$ that is ending at the final character or a trailing blank.</p>

<pre><code class="language-python">import numpy as np

def ctc_forward(probs, target):
    """
    probs: array (T, V) with softmax probs for each frame
           V includes all symbols + blank
    target: list of symbols, e.g. ['C','A','T']
    """
    # 1. Build extended target
    extended = ['_']
    for ch in target:
        extended += [ch, '_']
    S = len(extended)

    T = probs.shape[0]
    alpha = np.zeros((T, S))

    # 2. Initialize first frame
    alpha[0][0] = probs[0][extended[0]]   # prob of blank at t=0
    alpha[0][1] = probs[0][extended[1]]   # prob of 'C' at t=0

    # 3. Fill DP table
    for t in range(1, T):
        for s in range(S):
            stay = alpha[t-1][s]
            prev = alpha[t-1][s-1] if s-1 >= 0 else 0
            skip = alpha[t-1][s-2] if (s-2 >= 0 and extended[s] != extended[s-2]) else 0
            alpha[t][s] = probs[t][extended[s]] * (stay + prev + skip)

    # 4. Final probability
    return alpha[T-1][S-1] + alpha[T-1][S-2]
</code></pre>

   <p>This is our $p(y|x)$, we just efficiently computed the sum. This is the probability of target under the model.</p>

   <h2>5. Training with Forward-Backward</h2>
   
   <p>But, we also need gradients w.r.t. to the model’s softmax outputs at each frame during training. We need to know at frame 1 how much probability was aligned “A” vs blank. This is the <strong>posterior probability</strong>.</p>
   
   <p>The forward gives you the <strong>prefix</strong> probability, probability mass up to $(t,s)$. The backward gives you <strong>suffix</strong> probability, probability mass from $(t,s)$ to the end. When you use both you get how likely is that frame $t$ really belong to target position $s$?</p>

<pre><code class="language-python">import numpy as np

def ctc_forward_backward(probs, target):
    """
    probs: np.array of shape (T, V) with softmax probabilities
           (V includes all symbols + blank, accessed by dict)
    target: list of symbols, e.g. ['C','A','T']
    """
    # Build extended target with blanks
    extended = ['_']
    for ch in target:
        extended += [ch, '_']
    S = len(extended)   # extended length
    T = probs.shape[0]  # number of frames

    # Map symbol -> index in probs
    vocab = {ch: i for i, ch in enumerate(set(extended))}

    # Forward DP
    alpha = np.zeros((T, S))
    alpha[0][0] = probs[0, vocab[extended[0]]]
    alpha[0][1] = probs[0, vocab[extended[1]]]

    for t in range(1, T):
        for s in range(S):
            stay = alpha[t-1][s]
            prev = alpha[t-1][s-1] if s-1 >= 0 else 0
            skip = alpha[t-1][s-2] if (s-2 >= 0 and extended[s] != extended[s-2]) else 0
            alpha[t][s] = probs[t, vocab[extended[s]]] * (stay + prev + skip)

    # Backward DP
    beta = np.zeros((T, S))
    # initialize last frame
    beta[T-1][S-1] = probs[T-1, vocab[extended[S-1]]]   # last blank
    beta[T-1][S-2] = probs[T-1, vocab[extended[S-2]]]   # last symbol

    for t in reversed(range(T-1)):  # from T-2 down to 0
        for s in range(S):
            same = beta[t+1][s]
            nxt = beta[t+1][s+1] if s+1 < S else 0
            skip = beta[t+1][s+2] if (s+2 < S and extended[s] != extended[s+2]) else 0
            beta[t][s] = probs[t, vocab[extended[s]]] * (same + nxt + skip)

    # Total probability (should match forward and backward)
    total_prob = alpha[T-1][S-1] + alpha[T-1][S-2]
    
    return alpha, beta, total_prob, extended
</code></pre>

   <h2>6. Inference: Beam Search</h2>
   
   <p>At inference, we need to figure out which output sequence to return. If the model is confident and the output space is small or constrained then a greedy decoding is okay. But, that would throw away a lot of probability mass. <strong>Beam search</strong> recovers some of it by merging multiple paths that collapse to the same candidate sequence.</p>

<pre><code class="language-python">def simple_ctc_beam_search(probs, beam_size=3, top_k=3):
    """
    probs: (T, V) softmax probabilities over vocab (incl blank "_")
    """
    beams = {"": 1.0}  # start with empty prefix and prob=1

    for t in range(len(probs)):
        new_beams = {}
        # pick top_k symbols at this frame
        top_syms = np.argsort(probs[t])[-top_k:]
        for prefix, prob in beams.items():
            for sym in top_syms:
                p = probs[t][sym]
                if sym == "_":
                    new_prefix = prefix
                else:
                    # collapse rule: if repeat, don't double add
                    if prefix.endswith(sym):
                        new_prefix = prefix  # same seq
                    else:
                        new_prefix = prefix + sym
                # accumulate probability
                new_beams[new_prefix] = new_beams.get(new_prefix, 0) + prob * p
        # prune to top beam_size
        beams = dict(sorted(new_beams.items(), key=lambda x: -x[1])[:beam_size])

    return max(beams.items(), key=lambda x: x[1])
</code></pre>

</body>
</html>
