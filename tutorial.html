<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AI on Hardware Tutorials</title>
  <style>
    body { font-family: Arial, sans-serif; line-height: 1.6; margin: 20px; }
    h1, h2, h3 { color: #333; }
    ul { list-style-type: square; }
    table { width: 100%; border-collapse: collapse; margin-top: 10px; }
    th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
    th { background-color: #f4f4f4; }
    /* Navigation styling */
    nav { margin-bottom: 30px; padding: 10px; background: #f9f9f9; border: 1px solid #ddd; }
    nav ul { list-style: none; padding: 0; }
    nav li { display: inline-block; margin-right: 15px; }
    nav a { text-decoration: none; color: #007BFF; }
    nav a:hover { text-decoration: underline; }
    /* Section spacing */
    section { margin-bottom: 50px; }
  </style>
</head>
<body>
  <h1><a href="https://github.com/raminaeye/model-optimization?tab=readme-ov-file">Tutorials</a></h1>
  <nav>
    <ul>
      <li><a href="index.html">Home</a></li> | 
      <li><a href=pubs.html>Publications</a></li> | 
      <li><a href=Papers.html>What I'm reading</a></li> | 
      <li><a href=work.html>What I'm working on</a></li>
    </ul>
    <ul>
      <li><a href="#powerConsumption">Power Consumption</a></li> | 
      <li><a href="#knowledgeDistillation">Knowledge Distillation</a></li> | 
      <li><a href="#pruning">Pruning</a></li> | 
      <li><a href="#quantization">Quantization</a></li> | 
      <li><a href="#llm">LLM Fundamentals</a></li> 
    </ul>
  </nav>
  <!-- Knowledge Distillation Section -->
  <section id="knowledgeDistillation">
    <h2><a href="https://github.com/user-attachments/files/19404183/Knowledge.distillation.pdf">Knowledge Distillation</a></h2>
    <li><a href="https://github.com/raminaeye/model-optimization/tree/main/knowledge_distillation">My notebook on applying knowledge distillation</a></li>
    <h3>1. Introduction to Knowledge Distillation</h3>
    <p>Knowledge Distillation (KD) is a model compression technique where a smaller “student” model is trained to mimic the behavior of a larger “teacher” model.</p>
    <h4>Key Concepts:</h4>
    <ul>
      <li><strong>Teacher Model:</strong> A pre-trained, high-accuracy model.</li>
      <li><strong>Student Model:</strong> A smaller model that learns from the teacher.</li>
      <li><strong>Soft Targets:</strong> Probabilities or logits from the teacher model.</li>
      <li><strong>Distillation Loss:</strong> A combination of standard loss and KL divergence.</li>
    </ul>
    <h3>2. Motivation and Benefits</h3>
    <ul>
      <li>Model Compression</li>
      <li>Inference Efficiency</li>
      <li>Improved Generalization</li>
      <li>Flexibility</li>
    </ul>
    <h3>3. Core Techniques in Knowledge Distillation</h3>
    <h4>3.1 Logit Matching (Soft Targets)</h4>
    <p>Uses temperature scaling to soften output distribution.</p>
    <h4>3.2 Feature-Based Distillation</h4>
    <p>Aligns intermediate representations between teacher and student.</p>
    <h4>3.3 Relation-Based Distillation</h4>
    <p>Transfers relational knowledge like pairwise distances.</p>
    <h3>4. Distillation Loss Formulation</h3>
    <p>Uses a combination of standard task loss (e.g., cross-entropy) and distillation loss (e.g., KL divergence).</p>
    <h3>5. Practical Steps to Implement Knowledge Distillation</h3>
    <ul>
      <li>Train or select a teacher model.</li>
      <li>Design a smaller, efficient student model.</li>
      <li>Define the distillation loss.</li>
      <li>Combine with standard classification loss.</li>
      <li>Train the student model using both hard labels and soft targets.</li>
      <li>Evaluate and fine-tune the student model.</li>
    </ul>
    <h3>6. Impact on Hardware and Performance</h3>
    <ul>
      <li>Reduced Model Size</li>
      <li>Faster Inference</li>
      <li>Lower Energy Consumption</li>
    </ul>
    <h3>7. Advanced Techniques and Variations</h3>
    <h4>Ensemble Distillation</h4>
    <p>Uses multiple teacher models.</p>
    <h4>Self-Distillation</h4>
    <p>A model is its own teacher in iterative training.</p>
    <h4>Multi-Task and Cross-Modal Distillation</h4>
    <p>Transfers knowledge across tasks or modalities.</p>
    <h3>8. Real-World Applications</h3>
    <ul>
      <li>Deploying on Edge Devices</li>
      <li>Improving Generalization</li>
      <li>Accelerating Inference in Data Centers</li>
    </ul>
    <h3>9. Final Takeaways</h3>
    <p>Knowledge Distillation is a powerful method for model compression and efficiency improvement, making AI models more practical for real-world applications.</p>
  </section>

  <!-- Pruning Section -->
  <section id="pruning">
    <h2><a href="https://github.com/user-attachments/files/19404104/Pruning.pdf">Pruning</a></h2>
    <li><a href="https://github.com/raminaeye/model-optimization/tree/main/pruning">My notebook on applying pruning</a></li>
    </ul>
    <h3>1. Introduction</h3>
    <p>Modern deep neural networks are typically over-parameterized, leading to unnecessary computational and memory overhead. Pruning is a model compression technique aimed at eliminating redundant weights and neurons, yielding a sparse model that is lighter and more efficient.</p>
    <h3>2. Understanding Hardware Constraints</h3>
    <h4>Hardware Characteristics</h4>
    <ul>
      <li><strong>General-Purpose GPUs and CPUs:</strong>
        <ul>
          <li>Traditionally optimized for dense linear algebra.</li>
          <li>Unstructured sparsity may reduce model size but may not always yield runtime gains.</li>
          <li>Structured pruning removes entire neurons, channels, or filters for better efficiency.</li>
        </ul>
      </li>
      <li><strong>Specialized Accelerators & Edge Devices:</strong>
        <ul>
          <li>Some hardware supports unstructured sparsity for energy efficiency.</li>
          <li>For mobile or embedded devices, structured pruning is often preferred.</li>
        </ul>
      </li>
    </ul>
    <h4>Matching Pruning Strategy to Hardware</h4>
    <ul>
      <li>Determine if hardware supports sparse operations efficiently.</li>
      <li>Consider inference latency, energy consumption, and computational savings.</li>
    </ul>
    <h3>3. Overview of Pruning Techniques</h3>
    <h4>Basic Techniques</h4>
    <ul>
      <li><strong>Magnitude-Based Pruning:</strong> Removes weights below a certain threshold.</li>
      <li><strong>One-Shot vs. Iterative Pruning:</strong>
        <ul>
          <li>One-Shot: Removes a fixed percentage of weights in a single step.</li>
          <li>Iterative: Prunes gradually with retraining in between.</li>
        </ul>
      </li>
    </ul>
    <h4>Advanced Techniques</h4>
    <ul>
      <li>Adaptive thresholding for layer-specific pruning.</li>
      <li>Dynamic pruning schedules during training.</li>
      <li>Regularization-based pruning using L1 regularization.</li>
    </ul>
    <h3>4. Step-by-Step Pruning Process</h3>
    <h4>Step 1: Establish a Baseline</h4>
    <ul>
      <li>Evaluate model accuracy, latency, and resource utilization.</li>
      <li>Set goals such as reducing model size or improving efficiency.</li>
    </ul>
    <h4>Step 2: Select an Appropriate Pruning Strategy</h4>
    <ul>
      <li>Choose structured or unstructured pruning based on hardware constraints.</li>
      <li>Opt for iterative pruning with dynamic schedules.</li>
    </ul>
    <h4>Step 3: Implement Pruning</h4>
    <ul>
      <li>Use libraries like TensorFlow Model Optimization Toolkit or PyTorch.</li>
      <li>Apply pruning through weight masking and gradual sparsity increments.</li>
    </ul>
    <h4>Step 4: Fine-Tuning and Retraining</h4>
    <ul>
      <li>Retrain after each pruning round to recover accuracy.</li>
      <li>Monitor accuracy, sparsity, and convergence.</li>
    </ul>
    <h3>5. Evaluating the Impact</h3>
    <ul>
      <li>Analyze accuracy vs. sparsity trade-offs.</li>
      <li>Measure inference latency, memory usage, and energy consumption.</li>
    </ul>
    <h3>6. Integrating Pruning with Other Compression Techniques</h3>
    <ul>
      <li>Combine pruning with quantization for better efficiency.</li>
      <li>Use Neural Architecture Search (NAS) for optimized architectures.</li>
    </ul>
    <h3>7. Final Recommendations and Best Practices</h3>
    <ul>
      <li>Start with modest pruning ratios and gradually increase them.</li>
      <li>Use iterative pruning with fine-tuning to maintain accuracy.</li>
      <li>Evaluate pruned models on target hardware.</li>
    </ul>
    <h3>Conclusion</h3>
    <p>Pruning is a powerful technique for model optimization, balancing sparsity and performance. Understanding both model and hardware constraints is crucial to achieving meaningful efficiency gains.</p>
    <h3>Reference</h3>
    <ul>
      <li><a href="https://www.dropbox.com/scl/fi/6qspcmk8qayy7mft737gh/Lec03-Pruning-I.pdf">Lec03: Pruning I</a></li>
      <li><a href="https://www.dropbox.com/scl/fi/w5baiyci5cxl1ozpy6lsr/Lec04-Pruning-II.pdf">Lec04: Pruning II</a></li>
    </ul>
  </section>

  <!-- Quantization Section -->
  <section id="quantization">
    <h2><a href="https://github.com/user-attachments/files/19404105/Quantization.pdf">Quantization</a></h2>
    <ul>
      <li><a href="https://github.com/raminaeye/ML-Concepts/blob/main/notebooks/quantization/qunatization.ipynb
">My notebook on applying different quantization on MNIST dataset</a></li>
      <li><a href=Quantization>See my blog post on Quantization here</a></li>
  </section>
 <section id="powerConsumption">
   <h3>This section summarizes a few tutorials I vibed-wrote with LLMs. You can find the full document by clicking on the titles of each section.</h3>
 </section>
  <!-- Calculating Power Consumption Section -->
  <section id="powerConsumption">
    <h2><a href="https://github.com/user-attachments/files/19404184/AI.on.Hardware.pdf">Power Consumption</a></h2>
    <h3>1. Analytical Estimation:</h3>
    <ul>
      <li><strong>Operation Counting:</strong> Count the number of key operations (e.g., multiply–accumulate operations or MACs) performed during inference.</li>
      <li><strong>Memory Access Costs:</strong> Evaluate energy costs from loading weights and activations from memory.</li>
      <li><strong>Combined Models:</strong> Sum both computation and memory energy estimates to get the overall power consumption per inference.</li>
    </ul>
    <h3>2. Empirical Measurement:</h3>
    <ul>
      <li><strong>Hardware Counters and Tools:</strong> Use performance monitoring tools (e.g., RAPL on CPUs, vendor-specific counters on NPUs).</li>
      <li><strong>Profiling Frameworks:</strong> Tools like NeuralPower or frameworks within TensorFlow can help profile the energy footprint of ML models.</li>
    </ul>
    <h2>Typical Power Consumption in Wearable Devices</h2>
    <ul>
      <li><strong>Wearable System Power Budget:</strong> Many wearable devices operate on batteries with capacities around 200–500 mAh at ~3.7 V.</li>
      <li><strong>Component-Level Consumption:</strong>
        <ul>
          <li><strong>Sensors:</strong> Often in the microwatt (µW) to low milliwatt (mW) range.</li>
          <li><strong>Wireless Communication:</strong> Maintaining a Bluetooth connection might add tens to a few hundred mW.</li>
          <li><strong>Processing Units:</strong> General-purpose processors can be power-hungry, while dedicated NPUs or accelerators are more energy-efficient.</li>
        </ul>
      </li>
    </ul>
    <h2>Optimization Strategies Based on Power Constraints</h2>
    <table>
      <tr>
        <th>Aspect</th>
        <th>Challenge</th>
        <th>Optimization Strategy</th>
      </tr>
      <tr>
        <td>Computation</td>
        <td>High number of MACs increases dynamic power consumption</td>
        <td>Reduce model complexity (e.g., use lightweight architectures like MobileNet), quantize model parameters</td>
      </tr>
      <tr>
        <td>Memory Access</td>
        <td>Frequent loading of weights/activations from off-chip memory is costly</td>
        <td>Employ operator fusion, prune redundant connections</td>
      </tr>
      <tr>
        <td>Communication</td>
        <td>Wireless data transmission (e.g., Bluetooth) consumes significant power</td>
        <td>Minimize data transmission, use efficient data compression</td>
      </tr>
      <tr>
        <td>Hardware Utilization</td>
        <td>General-purpose processors are less energy-efficient</td>
        <td>Offload to NPUs, use dynamic voltage and frequency scaling</td>
      </tr>
    </table>
    <h2>Measuring Throughput and Latency</h2>
    <ul>
      <li><strong>Throughput Measurement:</strong> Run the model repeatedly and count inferences per second.</li>
      <li><strong>Latency Measurement:</strong> Time a single inference using profiling tools or built-in timers.</li>
    </ul>
    <h2>Memory Bandwidth</h2>
    <p>Memory Bandwidth is the maximum rate at which a device can read from or write to its memory.</p>
    <h3>Typical Values:</h3>
    <ul>
      <li><strong>Mobile/Embedded Devices:</strong> 5–30 GB/s</li>
      <li><strong>Desktop CPUs/GPUs:</strong> 20–100 GB/s (CPUs), 200–300 GB/s (high-end GPUs)</li>
    </ul>
    <h3>Optimization Strategies:</h3>
    <ul>
      <li><strong>Operator Fusion:</strong> Combine sequential operations into a single kernel.</li>
      <li><strong>Quantization & Pruning:</strong> Reduce model weight size to lessen memory demands.</li>
      <li><strong>Efficient Memory Access Patterns:</strong> Use tiling and optimized data layout to improve cache usage.</li>
    </ul>
  </section>

  <section id="llm">
  <h1>LLM Fundamentals, RAG, Training, Prompting, Evaluation & Post-Training</h1>
  </section>
  <div class="section">
    <h2>1. LLM Fundamentals</h2>
    
    <h3>Building Blocks</h3>
    <p>
      Large Language Models (LLMs) are built primarily on the Transformer architecture, which uses multi-head self-attention, layer normalization, and feed-forward networks to capture complex language patterns. Pre-training on enormous, diverse datasets (via next-token prediction or masked language modeling) is the key to developing their broad linguistic capabilities.
    </p>
    
    <h3>Applications</h3>
    <p>
      LLMs power a wide range of applications such as text generation, summarization, translation, question answering, content moderation, and even domain-specific tasks in areas like law, medicine, and finance.
    </p>
    
    <h3>Limitations</h3>
    <p>
      Despite their impressive capabilities, LLMs face several limitations:
    </p>
    <ul>
      <li><strong>Context Window:</strong> The fixed-size input limits the amount of text processed at one time.</li>
      <li><strong>Hallucinations:</strong> They can generate plausible-sounding but factually incorrect information.</li>
      <li><strong>Computational Cost:</strong> Both training and inference require significant resources.</li>
      <li><strong>Bias & Fairness:</strong> Models may reflect or amplify biases present in the training data.</li>
      <li><strong>Explainability:</strong> Understanding internal decision processes remains challenging.</li>
    </ul>
  </div>
  
  <div class="section">
    <h2>2. Retrieval-Augmented Generation (RAG)</h2>
    <p>
      RAG is a technique where a language model is combined with a retrieval mechanism. Instead of relying solely on its internal, static knowledge, the model can query an external database or knowledge base for up-to-date or domain-specific information.    </p>
    <p>
      <strong>What It Solves:</strong> RAG reduces hallucinations by grounding responses in external data and allows for real-time updates without needing to retrain the entire model. At inference time, when the model is given a prompt, it first retrieves relevant documents or snippets from a curated repository. These retrieved texts are then used to condition the generation process, often leading to outputs that are more factual and contextually rich.
    </p>
    <p>
      Since the external repository can be updated continuously, RAG systems can provide information that is more current than what the pre-trained model “knows.”By grounding responses in external, curated data, RAG can reduce hallucinations and improve factual consistency.It allows the model to adapt to specialized domains (e.g., legal, medical) without needing to retrain the entire model.
    </p>
    <p>
      <strong>Limitations:</strong> Its success depends on the quality of the retrieval mechanism and can add complexity and latency to the response process. The effectiveness of RAG depends heavily on the quality and relevance of the external documents retrieved. Combining the retrieval mechanism with generation in a seamless way is non-trivial, and errors in retrieval can propagate into the final output. Adding a retrieval step can introduce additional latency, which might be problematic in time-critical applications.
    </p>
  </div>
  
  <div class="section">
    <h2>3. LLM Training and Post-Training</h2>
    
    <h3>Pre-Training</h3>
    <p>
      In pre-training, LLMs are exposed to vast corpora of unannotated text using self-supervised learning objectives (e.g., next-token prediction), allowing the model to learn general language representations.Models are pre-trained on large datasets using objectives like next-word prediction (causal language modeling) or masked language modeling. This stage imparts general language understanding and world knowledge. The diversity and scale of the training data are critical; the more varied the text, the better the model can generalize.
    </p>
    
    <h3>Instruction Tuning</h3>
    <p>
      Instruction tuning fine-tunes a pre-trained model on datasets that include explicit instructions paired with ideal responses. This process aligns the model’s outputs with human expectations. This process involves training the model on a dataset of instructions and responses. The goal is to align the model’s behavior with human expectations, making it more effective in following user instructions. It helps the model understand and execute a variety of tasks even if they differ significantly from the data it was pre-trained on.
    </p>
    
    <h3>Reinforcement Learning from Human Feedback (RLHF)</h3>
    <p>
      RLHF uses human-provided feedback to further adjust the model’s behavior through reinforcement learning (often using PPO), ensuring that outputs better reflect human preferences. RLHF uses human evaluations to reward model outputs that are deemed helpful, correct, or safe. This feedback loop refines the model’s responses. The process aims to balance factual correctness, coherence, and helpfulness, though it can be challenging to scale and standardize across diverse use cases.
    </p>
    
    <h3>Parameter-Efficient Fine-Tuning (PEFT)</h3>
    <p>
      Techniques like LoRA adjust only a small subset of the model’s parameters during fine-tuning. This approach is both computationally efficient and cost-effective. PEFT techniques (e.g., adapters, LoRA) allow models to be fine-tuned on specific tasks or domains without updating all parameters. This reduces computational cost and memory usage. It enables rapid adaptation to new tasks while preserving the general capabilities of the original model.
    </p>
    
    <h3>Post-Training</h3>
    <p>
      Post-training refers to additional refinement stages after initial pre-training and fine-tuning. This can include:
    </p>
    <ul>
      <li><strong>Supervised Post-Tuning:</strong> Further training on high-quality, domain-specific or synthetic instruction-response pairs to improve performance.</li>
      <li><strong>Long-Context Training:</strong> Techniques to extend the model’s context window, allowing for processing longer documents.</li>
      <li><strong>Continual Adaptation:</strong> Incrementally updating the model with new data to keep its knowledge current.</li>
    </ul>
    <p>
      Post-training enables ongoing improvements and adaptation without the need to start from scratch, ensuring that the model remains state-of-the-art as new data and techniques become available.
    </p>
  </div>
  
  <div class="section">
    <h2>4. Prompting Techniques</h2>
    <p>
      Prompting techniques are crucial for coaxing the best performance out of LLMs. They include:
    </p>
    <ul>
      <li><strong>Zero-Shot and Few-Shot Prompting:</strong> Providing no or a few examples within the prompt to guide the response. The model is given a prompt without any examples, relying entirely on its pre-trained knowledge to generate an answer. The prompt includes a few examples of the task (demonstrations), which helps steer the model’s output more precisely.

</li>
      <li><strong>Chain-of-Thought (CoT) Prompting:</strong> Encouraging the model to articulate its reasoning step by step before arriving at a final answer.</li>
      <li><strong>Self-Consistency & Ensemble Prompting:</strong> Generating multiple reasoning paths and choosing the most consistent output. This method involves prompting the model to generate intermediate reasoning steps before arriving at a final answer. It has been shown to improve performance on complex reasoning tasks. Use CoT when a task requires multiple logical or inferential steps, such as math problems or multi-step decision making. Generating multiple reasoning paths and selecting the most consistent or frequent answer can improve reliability. Combining outputs from different prompt formulations can lead to more robust results.</li>
      <li><strong>Instruction Engineering:</strong> Carefully crafting prompts with explicit directions and context to shape the model’s output.</li>
    </ul>
  </div>
  
  <div class="section">
    <h2>5. Evaluation of LLMs</h2>
    <p>
      Clear and detailed instructions help the model understand the task better. For instance, instructing the model to “explain step-by-step” or “list in bullet points” can significantly affect the output style and accuracy. Structuring prompts to include relevant context and examples helps in guiding the model, especially in complex or multi-turn conversations. Evaluating LLMs differs significantly from traditional models. Traditional models (e.g., classifiers) are usually evaluated on accuracy or error rates. In contrast, LLMs produce diverse, open-ended text that requires more nuanced evaluation. Evaluating generative quality, coherence, factual accuracy, and safety often involves subjective human judgment rather than purely quantitative metrics. LLM outputs can be highly dependent on prompt phrasing and context, making standardized evaluation challenging. Since LLMs generate free-form text, evaluation must consider:
    </p>
    <ul>
      <li><strong>Human Evaluation:</strong> Assessing coherence, fluency, factual accuracy, and relevance through expert or crowd-sourced ratings. Involving expert or crowd-sourced evaluators to rate outputs on criteria such as relevance, coherence, and factuality.</li>
      <li><strong>Benchmark Datasets:</strong> Using standardized tests such as MMLU or GSM8K to quantitatively measure performance. Utilizing standardized datasets for tasks like question answering, summarization, or translation to compare model performance.</li>
      <li><strong>Automated Metrics:</strong> Metrics such as BLEU, ROUGE, and perplexity, along with newer methods for evaluating factual consistency. Metrics like BLEU, ROUGE, or perplexity are still used, but they are often supplemented with newer metrics aimed at capturing nuances in generated text (e.g., factual consistency scores).</li>
      <li><strong>Adversarial Testing:</strong> Challenging the model with difficult inputs to uncover weaknesses. Probing models with challenging or edge-case inputs to identify failure modes and biases.</li>
      <li><strong>User-Centric Measures:</strong> Evaluating the model’s effectiveness based on real-world usage and satisfaction. Evaluations based on real-world usability and satisfaction are increasingly important, particularly for applications in customer service or content creation.</li>
    </ul>
  </div>
  
  <div class="section">
    <h2>Conclusion</h2>
    <p>
      LLM Fundamentals focus on the transformer architecture, large-scale pre-training, and fine-tuning for diverse applications while grappling with issues like hallucination and bias. RAG enhances LLM outputs by grounding them in external data, improving factual accuracy and domain adaptation, though it adds complexity and dependency on the quality of the retrieval system. LLM Training spans from unsupervised pre-training to sophisticated techniques like instruction tuning, RLHF, and parameter-efficient fine-tuning, each playing a role in aligning the model with human intent. Prompting Techniques include a variety of strategies—from zero-shot and few-shot methods to chain-of-thought and ensemble prompting—to optimize the model’s performance for specific tasks. Evaluation of LLMs demands more than traditional metrics, combining human judgment, benchmark testing, automated scoring, and real-world performance metrics to capture the multifaceted quality of generative outputs.Large Language Models are complex systems built on the transformer architecture and trained on vast datasets. They are further refined through processes like instruction tuning, RLHF, and PEFT. Techniques such as RAG enhance their ability to provide accurate, up-to-date responses by integrating external data. Advanced prompting methods and multifaceted evaluation approaches are essential to harness their full potential. Finally, post-training allows continuous refinement and adaptation, ensuring that models remain robust and current.
    </p>
  </div>
  
</body>
</body>
</html>
