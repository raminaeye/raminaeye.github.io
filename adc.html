<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ADC Fundamentals</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            margin: 20px auto;
            max-width: 800px;
            padding: 0 20px;
            color: #333;
        }
        h2, h3 {
            border-bottom: 2px solid #eee;
            padding-bottom: 5px;
            margin-top: 35px;
        }
        h2 {
            font-size: 1.8em;
        }
        h3 {
            font-size: 1.5em;
        }
        p {
            margin-bottom: 15px;
        }
        strong {
            color: #000;
        }
        code, pre {
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
            background-color: #f6f8fa;
            border-radius: 5px;
        }
        code {
            padding: 0.2em 0.4em;
            font-size: 85%;
        }
        pre {
            padding: 15px;
            overflow-x: auto;
            white-space: pre-wrap; /* Allows diagrams to wrap if needed */
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        hr {
            border: 0;
            border-top: 2px solid #eee;
            margin: 40px 0;
        }
    </style>
</head>
<body>

    <h2>Important Note</h2>
    <p><strong>Please be aware that this document is based on my basic understanding of the topic. The information in here might be incorrect or incomplete, and I recommend that you double-check this info against other reliable sources.</strong></p>
    <p>Ramin Anushiravani<br>10/21/2025</p>

    <h2>Summary</h2>
    <p>This document explains how Analog-to-Digital Converters (ADCs) translate continuous analog signals into discrete digital values using parameters like bit depth, voltage reference, and gain. It details how this quantization process creates trade-offs between resolution (LSB) and quantization noise (SNR). Finally, it covers the role of sampling rates and anti-aliasing filters in accurately capturing the signal's frequency content without distortion (aliasing).</p>

    <hr>

    <h3>ADC</h3>
    <p>The brain produces analog signals, continuous voltage that can take any value. The ADC, analog to digital converter, is the component that does this translation.</p>
    <p>Every ADC has a reference voltage, <strong>V<sub>ref</sub></strong>. It defines the top and bottom of what the ADC can measure. ADC is differential, so a span of 2.4V means it can measure from -1.2V to 1.2V. ADC can take voltage within a range, -1.2V to 1.2V, and assigns each interval of voltage a digital code. Anything beyond this region gets saturated; the ADC output just flatlines at its maximum digital code.</p>
    <p>Quantization rounds the continuous voltage to the nearest available code. If analog input is a ramp, ADC is a staircase. Each stair step corresponds to one LSB (Least Significant bit). The finer the steps, the closer the digital version is to the real signal. The ADC resolution, number of bits, determines how precisely you can measure small voltage changes. That range is the reference voltage that determines how large a signal can be measured before saturation, clipping. These two together set the quantization granularity, the smallest detectable change. If ADC has 10 bits of resolution it can represent <strong>2<sup>10</sup></strong> values. Each bin would correspond to one discrete code, integers from -512 to +511.</p>

    <h3>LSB (Least Significant Bit)</h3>
    <p>The LSB represents the voltage difference between two adjacent digital codes. The LSB is the bridge between physical voltage and digital code. Mathematically,</p>
    <p><strong>LSB = (2 × V<sub>ref</sub>) / 2<sup>N</sup></strong></p>
    <p>Where N is the bit depth.</p>
    <p>If ADC range is ±1.2V and it has 10 bits, then the step size is 2.4V / 1024 = 2.34mV per code. Code 0 is -1.2V, and code 1 is -1.1977V, etc. Each step differs exactly by one LSB = 2.34mV. We usually call this step size LSB when measured in volts.</p>

    <h3>Amplifier (Gain)</h3>
    <p>The neural signals produce much smaller voltages, thousands times smaller, so if you directly connect to ADC it would read as zero because each step is 2.34mV. That’s where the amplifier, gain, comes in. The amplifier simply multiplies the electrode voltage by a constant factor.</p>
    <p><strong>V<sub>ADCinput</sub> = Gain × V<sub>electrode</sub></strong></p>
    <p>The amplifier brings the neural signals into a range that ADC can digitize accurately. While the <strong>LSB<sub>ADC</sub></strong> is 2.34mV/code, the LSB at electrode level is smaller because the amplifier multiplies that voltage by a gain. At 250 gain, the <strong>LSB<sub>electrode</sub></strong> is 9.375μV/code.</p>
    <p><strong>LSB<sub>electrode</sub> = V<sub>ref</sub> / (2<sup>N</sup> × G)</strong><br>
       <strong>V<sub>max, electrode</sub> = V<sub>ref</sub> / G</strong></p>
    <p>The gain affects both range and resolution equally. With smaller LSB you can detect smaller voltages but it also comes with smaller input ranges that saturate more easily, clipping risk. This means the amplifier must make sure that the largest expected electrode signal doesn’t exceed this range.</p>
    <p><strong>|V<sub>ADCinput</sub>| ≤ V<sub>ref</sub></strong><br>
       <strong>|G × V<sub>electrode</sub>| ≤ V<sub>ref</sub></strong><br>
       <strong>|V<sub>electrode</sub>| ≤ V<sub>ref</sub> / G</strong></p>
    <p>The maximum electrode voltage you can measure without saturation is inversely proportional to the gain.</p>
    
    <table>
        <thead>
            <tr>
                <th>Gain</th>
                <th>Max ADC input</th>
                <th>Electrode range peak-to-peak</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>x 250</td>
                <td>±1.2V</td>
                <td>4.8mV</td>
            </tr>
            <tr>
                <td>x 500</td>
                <td>±1.2V</td>
                <td>2.4mV</td>
            </tr>
            <tr>
                <td>x 1000</td>
                <td>±1.2V</td>
                <td>1.2mV</td>
            </tr>
        </tbody>
    </table>

    <p>So far, ADC converts continuous voltage, analog signals into discrete digital signals. <strong>V<sub>ref</sub></strong> is the max voltage ADC can see, quantization is rounding to the nearest integer, and LSB is how wide each step is.</p>
    <p>If you multiply the LSB by the total number of steps you get the total measured voltage span.</p>
    <p><strong>V<sub>max</sub> = (2<sup>(N-1)</sup> - 1) × LSB</strong></p>
    <p>This is the largest input voltage the ADC input can see before saturation.</p>
    <p>Changing the LSB directly changes the measured voltage range. For example, at LSB 2.34V, where gain setting is 2, the <strong>V<sub>max</sub></strong> is ±1.2V. Smaller LSB means higher resolution but smaller maximum voltage.</p>

    <h3>Quantization Error</h3>
    <p>Because ADC converts a continuous analog voltage to a discrete digital code, it must round the input to the nearest quantization level. This rounding introduces a quantization error. If LSB is 4.7μV, then any voltage between 10-14.7μV is rounded to the nearest code of 14.7μV. The max quantization error is <strong>LSB/2</strong>, so even a noiseless perfect signal would have 2.3μV uncertainty because of digitization.</p>
    <p>If you plot the quantization error for a slowly increasing signal it would look like a saw-tooth wave, ramps linearly between <strong>-½ LSB</strong> to <strong>+½ LSB</strong>, because the ADC snaps to the next step. For a real neural signal the waveform continuously changes at ADC step boundaries, so each crossing is where a sawtooth cycle resets. If you overlay these sawtooth error cycles but with slightly shifted phases they no longer line up, it blurs together like random noise. There’s no bias in quantization error, it’s zero, and the probability of any particular error value is roughly constant. That’s a definition of a uniform random variable, hence we treat quantization error as a uniform noise with</p>
    <p><strong>σ<sup>2</sup><sub>q</sub> = LSB<sup>2</sup> / 12</strong> with mean 0.</p>

    <h3>Signal to Noise Ratio (SNR)</h3>
    <p>The signal to noise ratio (SNR) compares the strength of your desired signal to the background noise level.</p>
    <p><strong>SNR = P<sub>signal</sub> / P<sub>noise</sub></strong></p>
    <p>In decibels (dB) this is</p>
    <p><strong>SNR<sub>dB</sub> = 10 log<sub>10</sub>(P<sub>signal</sub> / P<sub>noise</sub>)</strong></p>
    <p>Consider a full-cycle sine wave of amplitude A.</p>
    <p><strong>P<sub>signal</sub> = A<sup>2</sup> / 2</strong> where A is the maximum measurable voltage</p>
    <p>If the ADC has 2<sup>N</sup> codes, each spaced by 1 LSB, then</p>
    <p><strong>A = (2<sup>(N-1)</sup> - 1) × LSB ≈ 2<sup>(N-1)</sup> × LSB</strong><br>
       <strong>P<sub>noise</sub> = LSB<sup>2</sup> / 12</strong><br>
       <strong>SNR = 6 × (2<sup>(N-1)</sup>)<sup>2</sup> = 1.5 × 4<sup>(N-1)</sup> ≈ 6.02N + 1.76</strong></p>
    <p>Each additional bit increases SNR by 6 dB, which means twice the resolution or half the quantization noise amplitude.</p>

    <h3>Sampling Rate and Aliasing</h3>
    <p>So far we discussed the amplitude axis controlled by the LSB. The time axis is controlled by the sampling rate. The sampling rate tells you how many samples per second ADC can take. The signal bandwidth links to this sampling rate,</p>
    <p><strong>f<sub>s</sub> ≥ 2 × f<sub>max</sub></strong></p>
    <p>Where <strong>f<sub>max</sub></strong> is the highest frequency component of your analog signal and <strong>f<sub>s</sub> / 2</strong> is the Nyquist frequency. If you sample lower than that, the high frequency part of the signal folds back into lower frequencies and you get aliasing.</p>
    <p>Mathematically, what sampling actually does,</p>
    <p><strong>x[n] = x(t) | t = nT<sub>s</sub></strong> where <strong>T<sub>s</sub> = 1 / f<sub>s</sub></strong></p>
    <p>You keep samples every <strong>T<sub>s</sub></strong> seconds. This is similar to multiplying the continuous signal by a train of delta spike spaced by <strong>T<sub>s</sub></strong>. In the frequency domain that multiplication corresponds to repetition of the signal’s spectrum every <strong>f<sub>s</sub></strong>. If those repeats overlap you mix the frequencies. This is a fundamental property of the Fourier Transform, periodicity in one domain is repetition in the other domain. Multiplication in one domain is convolution in the other domain.</p>
    <p><strong>x<sub>s</sub>(t) = x(t) × train(t)</strong></p>
    <p>Multiplying the time domain by this train of spikes is convolving the spectrum with the frequency domain of that train. Convolution with spikes is replicating your original spectrum at each spike location.</p>

<pre>
Before sampling,
Frequency content:
      |------ Useful spectrum -------|
      0                               f
</pre>

<pre>
After sampling,
Frequency content (sampled):
      |------|------|------|------|
      0     f<sub>s</sub>    2f<sub>s</sub>   3f<sub>s</sub>   4f<sub>s</sub>
      ↑           ↑
   original    repeated copies
</pre>

    <p>Say the ADC sampling rate is 1 kHz, that means we sample every 1 ms. If our analog signal was a sine wave at 600 Hz, each cycle would last 1.67 ms. Because ADC can only represent up to Nyquist frequency of 500 Hz, anything above that mirrors back around 500 Hz.</p>
    <p><strong>F<sub>alias</sub> = |f<sub>sig</sub> - f<sub>s</sub>| = 400 Hz</strong></p>
    <p>Two different analog frequencies produce identical sample sequences when sampled at 1 kHz. Another way to look at aliasing is through phase. A sine wave of frequency <strong>f<sub>sig</sub></strong> completes one full 360° rotation at each period T = 1 / <strong>f<sub>sig</sub></strong>. So, the phase is,</p>
    <p><strong>phase(t) = 2π × f<sub>sig</sub> × t</strong><br>
       <strong>x(t) = sin(2π × f × t)</strong></p>
    <p>At 1 kHz with a 600 Hz sine wave, we won’t land on the same phase each time, the phase advances by some amount between samples. Because of the skipping ahead in cycles it shows up as lower frequencies, aliasing. The phase jumps around so much between samples that the ADC’s reconstruction sees a lower frequency mirror. This happens if you move more than 180° per sample, you skip ahead too far and the sample looks like a slower reverse motion at 400 Hz. At 600 Hz with 1 kHz the phase advances by 360 × 600 / 1000 = 216°</p>
    <p>Higher sampling rate means more data, higher power and better temporal precision. The quantization noise is spread over the full Nyquist band, so increasing the sampling rate spreads the noise thinner per Hz, slightly improving SNR per bandwidth.</p>

    <h3>Anti-Aliasing Filter</h3>
    <p>If you can’t increase the sampling rate, you can still avoid aliasing using anti-aliasing filtering. Before the ADC samples your analog signal the system inserts an analog low-pass filter, called anti-aliasing filter, that removes all frequencies above the Nyquist frequency. This filter chops off the high frequency parts of the signal so they can’t fold back.</p>
    <p><code>Analog Signal → [Low-pass Filter] → ADC → Digital samples</code></p>
    <p>The anti-aliasing low-pass cutoff is a little below Nyquist. Because filtering is not perfect, we typically oversample slightly so the filtering design constraint is easy for digital downsampling later.</p>
    <p>Filters have a transition band and it doesn’t suddenly go from 100% pass to 100% block, it rolls off gradually. A filter’s cut off is the point where the output power has fallen to half of its input power. Half power corresponds to -3 dB in amplitude, about 0.7 of output’s amplitude.</p>
    <p>The roll-off is the rate at which the filter attenuates the signals beyond the cutoff and it’s measured in dB per decade. A decade is 10x frequency.</p>
    <p>It’s how sharp the transition band is. The filter order adds another stage that makes the roll-off steeper. Higher order means steeper cutoff, stronger rejection of unwanted frequencies but also more complexity, more power and more phase distortion. If the Nyquist is close to the signal bandwidth, you need a filter that attenuates everything beyond Nyquist very strongly, that’s a higher-order filter.</p>
    <p>Let’s take a look at our aliasing example again. At 500 Hz cutoff frequency, the filter is only down at -3dB. Strong 600 Hz components would still leak through with full strength and alias down to 400 Hz, so you need to set the cutoff frequency lower so the attenuation is great, about -40 dB. The actual cutoff would depend on the filter and its order. A first order filter attenuates at -20 dB per decade and this gets multiplied by 2 by increasing the order by 1.</p>
    <p>If you want at least -40dB by 500 Hz, then you must start your filter roll-off at 400 Hz, where it’s -3 dB. For an n-th order butterworth low-pass filter, we have,</p>
    <p><strong>|H(f)| = 1 / sqrt(1 + (f / f<sub>c</sub>)<sup>2n</sup>)</strong></p>
    <p>And the attenuation is</p>
    <p><strong>A(f) = 20 × log<sub>10</sub>(1 / |H(f)|)</strong></p>
    <p>For a first order filter with cutoff frequency at 400 Hz we can compute attenuation at 500 Hz,</p>
    <p><strong>A(500) = 20 × log<sub>10</sub>(sqrt(1 + (500 / 400)<sup>2</sup>)) = 4.1 dB</strong></p>
    <p>This is very shallow. At order of 4, this is about 8.4 dB. If you want,</p>
    <p><strong>A(500) = 40</strong> then,<br>
       <strong>10 × log<sub>10</sub>(1 + (500 / f<sub>c</sub>)<sup>2n</sup>) = 40</strong><br>
       <strong>f<sub>c</sub> = 500 / (9999<sup>(1/2n)</sup>)</strong></p>
    <p>For n = 8 to get -40 dB at 500 Hz the cutoff frequency would be at 281 Hz. Remember that using higher order filters comes with side effects, phase shift. If your signal contains many frequencies at once then each component might get delayed by a different amount and when you combine them the timing is no longer aligned. The waveform shape is altered even if the spectrum looks fine. Common IIR filters like butterworth have non-linear phases outside their transition bands. The higher the order the more non-linearity and more total phase delay. That’s why sometimes it’s wiser to use two lower-order filters cascaded than one higher order filter.</p>
    <p>We’re typically interested in signals up to 250 Hz. For example high gamma signals are around 70-200 Hz. At 1 kHz sampling rate, with 500 Nyquist frequency, we can capture this band using a high-order filter. The timing of HGA can be slightly skewed because the filter's group delay ripples can extend well into 200 Hz.</p>

    <hr>
    <h3>Summary</h3>
    <p>In summary, this document outlined the fundamentals of Analog-to-Digital Conversion. It covered how ADCs use bit depth and voltage references to quantize signals (LSB), the importance of gain for signal amplification and managing the signal-to-noise ratio (SNR), and the critical role of sampling rates and anti-aliasing filters in accurately representing a signal's frequency content without distortion (aliasing).</p>

</body>
</html>
