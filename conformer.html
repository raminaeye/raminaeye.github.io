<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>The Conformer ASR Model</title>
  <style>
    body {
      font-family: sans-serif;
      max-width: 900px;
      margin: 0 auto;
      padding: 2rem;
      line-height: 1.6;
      color: #333;
    }
    h1, h2, h3, h4 {
      color: #2c3e50; /* Darker shade for better contrast */
      margin-top: 1.5em;
      margin-bottom: 0.5em;
    }
    h1 { font-size: 2.5em; border-bottom: 2px solid #3498db; padding-bottom: 0.3em;}
    h2 { font-size: 2em; border-bottom: 1px solid #bdc3c7; padding-bottom: 0.2em;}
    h3 { font-size: 1.5em; }
    h4 { font-size: 1.2em; color: #555;}

    nav { margin-bottom: 30px; padding: 10px; background: #ecf0f1; border: 1px solid #bdc3c7; border-radius: 4px;}
    nav ul { list-style: none; padding: 0; }
    nav li { display: inline-block; margin-right: 15px; }
    nav a { text-decoration: none; color: #3498db; font-weight: bold;}
    nav a:hover { text-decoration: underline; color: #2980b9;}

    pre {
      background: #f8f9f9; /* Lighter background for code blocks */
      padding: 1rem;
      overflow-x: auto;
      border: 1px solid #e1e4e8; /* Softer border */
      border-left: 4px solid #3498db; /* Accent border */
      border-radius: 4px;
      font-size: 0.9em;
    }
    code {
      font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
    }
    /* For inline code */
    p > code, li > code, table td > code {
      background: #e8eaed;
      padding: 0.2em 0.4em;
      border-radius: 3px;
      font-size: 0.85em;
    }
    pre code { /* Reset for code inside pre, already handled by pre styling */
        background: none;
        padding: 0;
        font-size: 1em; /* Ensure pre's font size is inherited */
    }
    ul, ol {
        padding-left: 20px;
    }
    li {
        margin-bottom: 0.5em;
    }
    strong {
        color: #2980b9;
    }
    hr {
      border: 0;
      height: 1px;
      background: #bdc3c7;
      margin-top: 2em;
      margin-bottom: 2em;
    }
  </style>

  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
        processEscapes: true
      }
    });
  </script>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
</head>
<body>
    <nav>
        <ul>
            <li><a href="#introduction">Introduction</a></li>
            <li><a href="#architecture">Architecture</a></li>
            <li><a href="#implementation">PyTorch Code</a></li>
            <li><a href="#streaming">Streaming & Output</a></li>
        </ul>
    </nav>

    <h1 id="introduction">The Conformer Model for ASR</h1>
    
    <h2>Introduction: Blending CNNs and Transformers</h2>
    <p>Let’s take a look at an ASR model that blends CNNs with transformers for speech. Vanilla transformers are great for global context but are weak at capturing local details like phoneme edges and formants. CNNs are excellent for local structure, but they miss global dependencies. The <strong>Conformer</strong>, a "convolution-augmented transformer," has both.</p>

    <p>Unlike models for text, an ASR model takes continuous audio as input. Because audio data has a high sampling rate, such as 16 kHz, we first need to extract acoustic features. Common choices are log-mel spectrogram or filterbank features. For one second of speech, you might get 100 frames with 80 dimensions each ($100 \times 80$). Just as an embedding layer projects 1D tokens into a vector space, in speech processing, there is a linear or convolutional layer that projects the acoustic features into the model's dimension, $d_{model}$. For example, this can result in an $80 \times 256$ matrix, so your token embeddings now have the dimensions $T \times d_{model}$ (e.g., $100 \times 256$).</p>

    <hr>
    
    <h2 id="architecture">Core Architecture of the Conformer Block</h2>

    <p>A transformer encoder block looks like this:<br>
    <code>x → [MHSA] → +residual → [FFN] → +residual → out</code>
    </p>

    <p>Conformer changes this to:<br>
    <code>x → [FFN(0.5)] → [MHSA] → [Conv] → [FFN(0.5)] → out</code>
    </p>

    <p>The Conformer block calls these two feed-forward networks a "macaron-style feed-forward network," so named because the main attention and convolution modules are sandwiched between two FFNs, like the filling in a macaron. They add capacity and non-linearity but don’t mix information across time steps. They scale the FFN by half to match the contribution of one FFN in a vanilla transformer.</p>

    <p>The first FFN applies a 2-layer MLP to each frame independently. The dimension might be expanded to $d_{ff}$ (e.g., 1024) with some activations, which is then scaled back so a half-scaled residual connection can be added to the input.</p>

    <h3>Multi-Head Self-Attention with Relative Positional Encoding</h3>
    <p>So far, the input is $B \times T \times d_{model}$; this is the output from the first FFN and its residual connection. Now, you project this input, X, into queries, keys, and values:</p>
    $$Q = XW_q^i, \quad K = XW_k^i, \quad V = XW_v^i$$

    <p>Where the $W$ weight matrices are ${d_{model}}/{k} \times {d_{model}}/{k}$ for $k$ heads. You then compute attention:</p>
    $$\text{Attn}(Q, K, V) = \text{Softmax}\left(\frac{QK^T}{\sqrt{d_k}}\right)V$$

    <p>Concatenate the heads, project back with $W_o$, and add the residual:</p>
    $$Y = X + \text{MHSA}(X)$$

    <p>This is almost the same as a vanilla transformer, but instead of sinusoidal encodings, it uses <strong>relative positions</strong>, which generalize better to long sequences and relative timing. With absolute positional encodings, for each input position, you would update the input as $x_t \leftarrow x_t + PE(t)$. The model is given the known positions, and the query and key themselves get shifted by this absolute index.</p>

    <p>With relative positional encoding, we don’t alter the input embeddings directly. Instead, we introduce an extra bias term in the attention score based on the relative distance. The model learns biases based on the relative distances between tokens. Speech is shift-invariant—a phoneme like "ba" at 1 second and 10 seconds should be treated the same. What matters is how far apart the tokens are, not their absolute index.</p>

    $$\text{score}(i,j) = Q_i \cdot K_j + Q_i \cdot r_{(i-j)}$$

    <p>Here, $r_{(i-j)}$ is a learned embedding for the relative offset between positions $i$ and $j$. We define a maximum relative distance, and this offset can be anywhere between $-L \dots 0 \dots L$, where each row corresponds to a $d_k$ vector space. For a given pair, we look up the relative embedding and perform a dot product with the query, which gets added to the attention scores. The embedding table has dimensions $(2L+1) \times d_k$. You can share this R matrix across all heads.</p>

    <h3>The Convolution Module</h3>
    <p>Next is the convolution module, which is the big difference from vanilla transformers. This is a depthwise separable convolution used to explicitly model local sequential structure.</p>

    <p>The input is now the context-enriched sequence, wherein each frame has been mixed with others and long-range dependencies have been learned. The shape is still $B \times T \times d_{model}$. The convolution module takes this input and applies local convolutional patterns to learn short-term temporal patterns on top of the long-range dependencies already captured by the attention mechanism.</p>

    <p>The convolution module looks similar to those in EfficientNet and MobileNet.</p>
    <ol>
        <li>The features are first passed to a <strong>LayerNorm</strong> to be normalized along the $d_{model}$ dimension.</li>
        <li>Then, a <strong>pointwise convolution</strong> with a <strong>Gated Linear Unit (GLU)</strong> activation is applied. The pointwise convolution expands the number of channels to $2 \times d_{model}$. The GLU works by halving the channels and applying the operation $A \cdot \sigma(B)$, where B acts as a learned gate controlling how much of A to pass. The output dimension remains $B \times T \times d_{model}$.</li>
        <li>Then, a <strong>depthwise convolution</strong> is applied along the time axis. Each channel has its own convolution filter (so there is no cross-channel mixing), often with a kernel size equivalent to 150 ms. This gives each feature map a local receptive field over time. The input is padded ('same') such that the output from this step remains the same size as the input. In streaming ASR, you’d switch to causal padding (padding only on the left, so the model doesn’t peek into the future). At this point, the representation is channel-local and time-dependent.</li>
    </ol>

    <h3>Normalization Strategy: LayerNorm vs. BatchNorm</h3>
    <p>Let’s think: would you use LayerNorm or BatchNorm after this? LayerNorm would normalize per frame across all channels, so it could actually wash away the learned temporal filters. If you use BatchNorm, it normalizes per channel but across time and the batch. This way, each channel keeps its identity and normalization is consistent across time, which helps stabilize the convolution filters. So, BatchNorm makes more sense here, although it has challenges with running inference. BN would output zero-mean and unit-variance activations, so an activation function would help. <strong>Swish</strong> would let small negative values pass through, which can be crucial in audio processing.</p>

    <p>Let’s briefly discuss BatchNorm during training and inference. During training, BatchNorm computes the mean and variance of the batch and time dimensions for each channel to normalize the values, along with learnable scale ($\gamma$) and shift ($\beta$) parameters for each channel. It additionally keeps a running estimate of both mean and variance, which is not used during the training forward pass but is stored to be used during inference later. During inference, you don’t use the batch statistics of the test data. You use the stored running stats along with the same learnable parameters to normalize the data:</p>
    $$x_{norm} = \gamma \cdot \frac{x - \mu_{\text{running}}}{\sqrt{\sigma^2_{\text{running}} + \epsilon}} + \beta$$

    <p>Now, with streaming ASR, the issue is that during training, the stats were computed on long sequences and full batches of data. During streaming, you’re normalizing with global averages that don’t match the local chunk you’re currently processing. Additionally, in streaming, you don’t want to wait for future frames to compute stats, so you need a causal or online version of BatchNorm. There are variations of causal BN where the mean and variance are computed over frames $\le t$, so normalization only depends on the past. It’s incrementally updated as new frames arrive. There’s also a sliding-window BN that updates based only on the last W frames. In the beginning, however, these statistics can be unreliable, so they typically kick in once the state becomes reliable. Alternatively, you can use other normalizations that are more real-time friendly, like LayerNorm.</p>
    
    <h3>Completing the Conformer Block</h3>
    <p>Anyway, the Conformer then applies a BatchNorm and a Swish activation. Finally, another pointwise convolution with dropout is applied, which performs a $d_{model} \rightarrow d_{model}$ mapping. Lastly, a residual connection is added from the start of the module to its output. This might seem redundant, but it introduces another cross-channel interaction which can be helpful for expressiveness, as depthwise convolution is a per-channel, local filter.</p>

    <p>This is our convolution block. The output from the convolution block remains $B \times T \times d_{model}$. After this, another feed-forward network, similar to the one before, is applied to each frame with a residual connection to complete the macaron-style design. It expands $d_{model}$ to $d_{ff}$, applies a non-linearity, projects back to $d_{model}$ with dropout, and adds a scaled version of that as a residual. The shape remains $B \times T \times d_{model}$. This helps with stacking blocks, and we know that machine learning practitioners love stacking blocks!</p>

    <p>The first FFN before the attention module enriches the frame-level features before they interacted globally. The second FFN enriches the representation after it has been mixed both globally and locally. This FFN symmetry is what is claimed to make the block more expressive and stable.</p>

    <hr>
    
    <h2 id="implementation">PyTorch Implementation</h2>
<pre><code class="language-python">
import torch
import torch.nn as nn
import torch.nn.functional as F

# -------------------------------
# 1. Macaron-style FeedForward
# -------------------------------
class ConformerFFN(nn.Module):
    def __init__(self, d_model, d_ff, dropout=0.1):
        super().__init__()
        self.linear1 = nn.Linear(d_model, d_ff)
        self.linear2 = nn.Linear(d_ff, d_model)
        self.dropout = nn.Dropout(dropout)
        self.activation = nn.SiLU()  # Swish

    def forward(self, x):
        out = self.linear1(x)
        out = self.activation(out)
        out = self.dropout(out)
        out = self.linear2(out)
        out = self.dropout(out)
        return x + 0.5 * out   # Macaron: scale by 0.5
        
# -------------------------------
# 2. Multi-Head Self-Attention (vanilla version, can extend with relative PE)
# -------------------------------
class MHSA(nn.Module):
    def __init__(self, d_model, num_heads, dropout=0.1):
        super().__init__()
        assert d_model % num_heads == 0
        self.h = num_heads
        self.d_k = d_model // num_heads

        self.W_q = nn.Linear(d_model, d_model)
        self.W_k = nn.Linear(d_model, d_model)
        self.W_v = nn.Linear(d_model, d_model)
        self.W_o = nn.Linear(d_model, d_model)
        self.dropout = nn.Dropout(dropout)

    def forward(self, x, mask=None):
        B, T, D = x.shape

        Q = self.W_q(x).view(B, T, self.h, self.d_k).transpose(1, 2)
        K = self.W_k(x).view(B, T, self.h, self.d_k).transpose(1, 2)
        V = self.W_v(x).view(B, T, self.h, self.d_k).transpose(1, 2)

        scores = torch.matmul(Q, K.transpose(-2, -1)) / (self.d_k ** 0.5)
        if mask is not None:
            scores = scores.masked_fill(mask == 0, float("-inf"))
        attn = F.softmax(scores, dim=-1)
        out = torch.matmul(attn, V)

        out = out.transpose(1, 2).contiguous().view(B, T, D)
        return x + self.dropout(self.W_o(out))  # residual

# -------------------------------
# 3. Convolution Module
# -------------------------------
class ConformerConvModule(nn.Module):
    def __init__(self, d_model, kernel_size=15, dropout=0.1, causal=False):
        super().__init__()
        self.layer_norm = nn.LayerNorm(d_model)
        self.pointwise_conv1 = nn.Conv1d(d_model, 2*d_model, kernel_size=1)
        padding = (kernel_size - 1) if causal else (kernel_size - 1) // 2
        self.depthwise_conv = nn.Conv1d(
            d_model, d_model, kernel_size,
            groups=d_model, padding=padding
        )
        self.causal = causal
        self.batch_norm = nn.BatchNorm1d(d_model)
        self.pointwise_conv2 = nn.Conv1d(d_model, d_model, kernel_size=1)
        self.dropout = nn.Dropout(dropout)

    def forward(self, x):
        residual = x
        x = self.layer_norm(x)
        x = x.transpose(1, 2)  # (B, d_model, T)

        x = self.pointwise_conv1(x)
        A, B = x.chunk(2, dim=1)
        x = A * torch.sigmoid(B)  # GLU

        x = self.depthwise_conv(x)
        if self.causal:
            x = x[:, :, :residual.size(1)]  # trim if causal

        x = self.batch_norm(x)
        x = F.silu(x)
        x = self.pointwise_conv2(x)

        x = x.transpose(1, 2)  # back to (B, T, d_model)
        return residual + self.dropout(x)  # residual

# -------------------------------
# 4. Full Conformer Block
# -------------------------------
class ConformerBlock(nn.Module):
    def __init__(self, d_model=256, d_ff=1024, num_heads=4, kernel_size=15, dropout=0.1, causal=False):
        super().__init__()
        self.ffn1 = ConformerFFN(d_model, d_ff, dropout)
        self.mhsa = MHSA(d_model, num_heads, dropout)
        self.conv = ConformerConvModule(d_model, kernel_size, dropout, causal)
        self.ffn2 = ConformerFFN(d_model, d_ff, dropout)
        self.final_ln = nn.LayerNorm(d_model)  # often added at block end

    def forward(self, x, mask=None):
        x = self.ffn1(x)
        x = self.mhsa(x, mask)
        x = self.conv(x)
        x = self.ffn2(x)
        return self.final_ln(x)
</code></pre>

    <hr>
    
    <h2 id="streaming">Streaming, Real-Time Applications, and Output</h2>

    <p>Now, how do you make the Conformer work in real-time? The attention mechanism, as we mentioned earlier, needs to change to a streaming attention where we restrict how far queries can look back using a fixed attention window with a causal mask. Sometimes speech can be ambiguous if you don’t peek a little into the future, so we can allow each frame to have a look-ahead by a fixed number of frames. This adds some latency but improves the model, and it can be easily configured in the attention mask. Additionally, you can make your multi-head attention into a multi-scale multi-head attention. Because information varies in length—a phoneme can be shorter, while syllables and words are longer—one head might be configured to span more frames than others to capture these different relationships.</p>

    <p>The convolution module uses "same" padding, which will need to change to causal padding, and the normalization, as we discussed in depth, needs to change as well.</p>

    <p>Okay, now we have our Conformer block, and we can stack several Conformer blocks to enrich the acoustic embeddings. Now we need to map the output to text. What we have are frame-level embeddings that need to be converted back to words or tokens.</p>

    <p>You can add a linear layer after the stack of Conformer blocks that takes the $d_{model}$ dimension to $V$, the number of words, tokens, or phonemes in the vocabulary. The output is $Z$, a tensor of shape $B \times T \times V$. Then, take the model outputs (logits, which are unnormalized scores) and pass them through a softmax function for each frame to get output probabilities.</p>
    $$P(t,v) = \frac{\exp(Z_{t,v})}{\sum_{v'} \exp(Z_{t,v'})}$$
    <p>Once you have this, you need to use a CTC loss to align the output probabilities with the text.</p>

</body>
</html>
